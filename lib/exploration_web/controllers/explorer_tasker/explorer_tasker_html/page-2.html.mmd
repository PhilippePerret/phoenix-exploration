<%= raw @titre %>
<%= raw link_other_pages(@page_index, @projet) %>

Maintenant, je veux rejoindre la liste des tÃ¢ches aprÃ¨s en avoir crÃ©Ã© une.

Mais quand je reviens Ã  : 

~~~elixir
# Dans handle_event("save" de tache.ex
{:ok, tache} ->
	socket
  |> put_flash(:info, "TÃ¢che crÃ©Ã©e avec succÃ¨sÂ !")
  |> redirect(to: ~p"/taches/#{tache}")
~~~

â€¦ Ã§a lÃ¨ve une erreur :

~~~bash
Compiling 2 files (.ex)
    error: undefined function sigil_p/2 (expected Try1Web.Tache to
    define such a function or for it to be imported, but none are
    available)
    â”‚
 42 â”‚         |> redirect(to: ~p"/taches/#{tache}")
    â”‚                         ^^^^^^^
    â”‚
    â””â”€ (try1 0.1.0) lib/try1_web/live/taches/tache.ex:42:25: 
    Try1Web.Tache.handle_event/3
~~~

Pour palier cette erreur, ChatGPT mâ€™a fait ajoutÃ© dans le fichier path(lib/try1_web.ex)Â :

~~~elixir
def live_view do
	quote do
  	use Phoenix.LiveView,
    	layout: {Try1Web.Layouts, :app}

		@router Try1Web.Router # <==== Ã‡A

    unquote(html_helpers())
  end
end

~~~

MAIS Ã‡A NE FONCTIONNE PAS.

Pour avoir les messages dans la page, jâ€™ai ajoutÃ© `<.flash_group flash={@flash} />` dans mon root **Ã  la ligne 4** :

~~~html
# in try1_web/components/layouts/root.html.heex

<body class="bg-white">
	<.flash_group flash={@flash} />
  <%= @inner_content %>
</body>

~~~

De cette maniÃ¨re, quand je crÃ©e la nouvelle tÃ¢che, Ã§a mâ€™Ã©crit le message.

### Vers la liste des tÃ¢ches

Maintenant, je voudrais que lorsque jâ€™ai enregistrÃ© la tÃ¢che, on redirige vers la liste des tÃ¢ches avec la route path(/taches/list)

Je commence par crÃ©er la route :

~~~elixir
# dans router.ex

	scope "/taches", Try1Web do
    pipe_through :browser

    get "list", TachesController, :list 			# <===
    live "/new", Tache #, :new
  end

~~~

Cette fois, jâ€™utilise un contrÃ´leur (je me dis que pour cette liste je nâ€™aurai pas besoin de contrÃ´ler Ã§a en LiveView mais câ€™est surtout pour voir si jâ€™arrive Ã  faire Ã§a).

Bien sÃ»r, Ã§a provoque une erreur puisque le contrÃ´leur nâ€™existe pas.

Je le crÃ©e dans un fichier path(/lib/try1web/controllers/taches_controller.ex) dans lequel je mets :

~~~elixir
defmodule Try1Web.TachesController do
  use Try1Web, :controller

  def list(conn, _params) do
    text(conn, "La liste des tÃ¢ches.")
  end
  
end
~~~

Cette mÃ©thode fonctionne parfaitement et quand je crÃ©e une nouvelle tÃ¢che jâ€™affiche juste Â«Â La liste des tÃ¢chesÂ Â» dans la page.

Je vais crÃ©er une vue pour faire : 

~~~elixir
defmodule Try1Web.TachesController do
  use Try1Web, :controller

  def list(conn, _params) do
    render(conn, :list)
  end
  
end
~~~

Je crÃ©e dÃ©jÃ  le module HTML qui va permettre de gÃ©rer la page HTML, dans path(lib/try1_web/controllers/taches_html.ex) :

~~~elixir
defmodule Try1Web.TachesHTML do

  use Try1Web, :html

  embed_templates "taches_html/*"

end
~~~

Ensuite je crÃ©e la vue dans Â :
path(lib/try1_web/controllers/taches_html/list.html.heex) avec un peu de codeÂ :

~~~html
<h1>Liste des tÃ¢ches</h1
~~~

> Note : Dans `lib/try1_web/components/layouts/app.html.heex` j'ai dÃ» retirer le `<header>` pour ne pas avoir lâ€™entÃªte par dÃ©faut de Phoenix.

> TODO : Penser Ã  rÃ©gler le problÃ¨me du formulaire qui ne traite plus les erreurs, maintenant. Ã‡a recharge la page, mais Ã§a ne fait rien.

â€¦

Je galÃ¨re bien pour essayer dâ€™enregistrer la tÃ¢che et de passer Ã  la suiteâ€¦

Et puis un moment, en ajoutant :

~~~elixir
  use Try1Web, :live_view
~~~

â€¦ au-dessus du module `Try1Web.Tache` dans path(lib/try1_web/live/taches/tache.ex) jâ€™obtiens un truc diffÃ©rent :

* les styles ont lâ€™air de sâ€™appliquer
* les messages dâ€™erreur sâ€™affichent
* je nâ€™ai plus de problÃ¨me avec la ligne `redirect(to: {~p"/taches/list"})` (mÃªme si Ã§a ne fonctionne pas encore)

â€¦ mais Ã§a nâ€™enregistre toujours pas, en mettant un message dâ€™erreur que je nâ€™ai pas le temps de lire (Â«Â hangÂ Â» quelque chose).

### Explication galÃ¨re

Ma galÃ¨re venait simplement du fait que je croyais que `redirect/3` retournait un tuple de type `{:noreply, ...}` ou autreâ€¦ Alors quâ€™en fait, dans la fonction Ã©vÃ¨nement, il faut que je mette :

~~~elixir
def handle_event("save", %{"tache" => tparams}, socket) do
	case Taches.creer_la_tache(tparams) do
  	{:ok, _tache} ->
    	{:noreply, socket
      	|> put_flash(:info, "TÃ¢che crÃ©Ã©e avec succÃ¨sÂ !")
        |> redirect(to: ~p"/taches/list")
      }
    {:error, %Ecto.Changeset{} = changeset} ->
    	{:noreply, socket 
                 |> assign(check_errors: true) 
                 |> to_form(changeset)}
	end
end

~~~

Apparemment, il est donc prÃ©fÃ©rable que je remplace `use Phoenix.LiveView` par `use Try1Web, :live_view` (qui permet dâ€™avoir les sigils â€” au moins ~p).

### Poursuite affichage liste

Je poursuis lâ€™affichage de la liste des tÃ¢ches (avec toutes mes manips, je commence Ã  en avoir pas mal)

Jâ€™ai fait tout Ã  lâ€™heure une vue pour la liste, je ne sais plus si jâ€™en ai parlÃ©. Elle contient (dans le fichierÂ path(try1_web/controllers/taches_html/list.html.heex)) :

~~~html
<h1>Liste des tÃ¢ches</h1>

<.link 
  href={~p"/taches/new"}>
  <button class="p-4 border-4">CrÃ©er une nouvelle tÃ¢che</button>
</.link>

<.table id="taches" rows={@taches}>

</.table>

~~~

Pour le moment, si jâ€™affiche la liste (en crÃ©ant une nouvelle tÃ¢che), Ã§a mâ€™indique que `@taches` n'est pas connue et pour cause. Donc je lâ€™ajoute au rendu :

~~~elixir
defmodule Try1Web.TachesController do

  use Try1Web, :controller

  alias Try1.Taches

  def list(conn, _params) do
    render(
    	conn, 
    	:list, 
    	taches: Taches.liste_des_taches() # <= ici
    	)
  end

end
~~~

> Rappel : liste_des_taches a Ã©tÃ© dÃ©fini dans le fichier path(lib/try1/taches.ex) et retourne simplement `Repo.all(Tache)`

Cette fois-ci, la vue connait `@taches` mais se plaint que `key :col not found in: %{...}`. La map est vraisemblablement celle envoyÃ©e par `<.table>`.

Je vais fouiller un peu cette fonction-balise.

â€¦

En fait, il suffit de dÃ©finir les colonnes de la table Ã  lâ€™aide de :

~~~html
<.table id="taches" rows={@taches}>
	<:col 
		:let={tache} 
		label="titre"
	>
		<%= tache.titre %>
	</:col>
</.table>
~~~

On donne dans `:let=` la valeur quâ€™on utilisera dans `<%= <var> %>`.

Je vais ajouter aussi la colonne `due_at` pour essayer de la formater.

~~~html
<.table id="taches" rows={@taches}>
	<:col 
		:let={tache} 
		label="titre"
	>
		<%= tache.titre %>
	</:col>
  <:col
    :let={tache}
    label="due Ã "
  >
    <%= tache.due_at %>
  </:col>
</.table>
~~~

Puisque je veux formater la date, je vais en profiter pour faire un helper :

~~~html
  <:col
    :let={tache}
    label="due Ã "
  >
    <%= formate_date(tache.due_at) %>
  </:col>
~~~

Cette mÃ©thode (aprÃ¨s avoir tÃ¢tonner) doit sâ€™â€™implÃ©menter dans le fichier path(taches_html.ex) :

~~~elixir
def formate_date(date) do
	date
end
~~~

Il doit surement exister avec `Gettext` des mÃ©thodes pratiques, mais je vais tout fait avec cette date.

La mÃ©thode finale Ã  laquelle jâ€™arrive (merci Ruby) :

~~~elixir
	@doc """
	Retourne la date et l'heure sous la forme
	jj/mm/aaaa - h:mm
	
	Si l'annÃ©e est la mÃªme qu'aujourd'hui, le
	format de la date se limite Ã  "jj/mm"
	
		iex> formate_date(~N[2001-11-30 06:32:15])
		20/11/2001 - 06:32:15
	"""
	def formate_date(date) do
    str = "#{date.day}/#{date.month}"
    # On ajoute l'annÃ©e si elle diffÃ¨re de 
    # l'annÃ©e courante
    if date.year != DateTime.utc_now.year do
      str = str <> "/#{date.year}"
    end
    # On ajoute le temps
    str = str <> " - #{date.hour}:#{date.minute}"

    str
  end

~~~

### Petits boutons outils

Je voudrais maintenant des boutons-outils pour :

* Ã©diter la tÃ¢che
* supprimer la tÃ¢che

Jâ€™ajoute ces deux colonnes Ã  ma table :

~~~html
  <:col :let={tache}>
    <.link
      href={~p"/taches/#{tache}/edit"}
      >
      <button>âœğŸ½</button>
    </.link>
  </:col>
  <:col :let={tache}>
    <.link href={~p"/taches/#{tache}/delete"}>
      <button>ğŸ—‘ï¸</button>
    </.link>
  </:col>
~~~

Je vais implÃ©menter dâ€™abord la mÃ©thode pour dÃ©truire une tÃ¢che (sans confirmation pour le moment, mais je sais quâ€™il existe un process).

Jâ€™ajoute le traitement de la route. Jâ€™essaie dâ€™abord de le faire avec un `live` pour voir si je peux le faire sans recharger la page (si jâ€™ai bien compris) :

~~~elixir
# in router.ex

scope "/taches/:id", Try1Web do

	live "/new", Tache
	live "/delete", TacheRem
end
~~~

Jâ€™ai tout mis en place dans un module `TacheRem` (Â«Â RemÂ Â» pour Â«Â RemoveÂ Â») car en fait jâ€™ai compris, peut-Ãªtre Ã  tort, quâ€™il faut un module par route (puisque `live` ci-dessus ne semble admettre que 2 paramÃ¨tres).

Donc, jâ€™ai crÃ©Ã© (assez facilement, je suis content) le module<br />path(lib/try1_web/live/taches/tache_rem.ex)Â :

~~~elixir
defmodule Try1Web.TacheRem do
  use Try1Web, :live_view
  import Try1Web.CoreComponents
~~~

Câ€™est la base, ensuite je fais la fonction requise `render` pour pouvoir valider la suppression (toujours dans le fichier ci-dessus).

~~~elixir
  def render(assigns) do
    ~H"""
    <h2>Confirmation de la suppression</h2>
    <div>
    	Merci de confirmer la suppression de
    	la tÃ¢che #<%= @tache_id %>.
    </div>
    <div class="center">
      <.button phx-click="remove_tache">
        DÃ©truire la tÃ¢che <%= @tache_id %>
      </.button>
    </div>

    """
  end
~~~

Ci-dessus, on notera simplement :

* la propriÃ©tÃ© `tache_id` quâ€™il faudra assigner au socket en temps voulu,
* le bouton contenant `phx-click` et dÃ©crivant donc ce qui se passera en *live* quand on cliquera sur le bouton (jâ€™Ã©tais parti au dÃ©part sur un formulaire mais câ€™est tout Ã  fait inutile).
* lâ€™Ã©vÃ¨nement Â«Â remove_tacheÂ Â» que je vais invoquer en cliquant sur le bouton.

Je poursuis le fichier avec la fonction requise `mount`Â :

~~~elixir
  def mount(%{"id" => tache_id}, _session, socket) do
    {:ok, assign(socket, :tache_id, tache_id)}
  end
~~~

Ici, on remarquera comment je rÃ©cupÃ¨re lâ€™identifiant de la tÃ¢che. Il Ã©tait nommÃ© `:id` dans la route, donc je le rÃ©cupÃ¨re par `â€œidâ€` dans les paramÃ¨tres ici (1er paramÃ¨tre de la fonction â€” je commence Ã  comprendre un peu comment fonctionne ces Map).

Et ensuite, ligne 2, je nâ€™oublie pas dâ€™assigner la valeur Ã  `socket` pour pouvoir la rÃ©cupÃ©rer dans le render.

Enfin, puisque lâ€™Ã©vÃ¨nement gÃ©nÃ©rÃ© pour provoquer la destruction sâ€™appelle `remove_tache`, je crÃ©e la fonction ad-hoc :

~~~elixir
 def handle_event("remove_tache", params, socket) do
 		tache_id = socket.assigns.tache_id
 		msg = "J'ai dÃ©truit la tÃ¢che ##{tache_id}."
    socket = socket
    |> put_flash(:info, msg)
    {:noreply, socket}
  end
~~~

Pour le moment, cette fonction ne fait rien dâ€™autre quâ€™afficher un message victorieux alors quâ€™elle nâ€™a rien fait de sa vieâ€¦

<%= raw link_other_pages(@page_index, @projet) %>
