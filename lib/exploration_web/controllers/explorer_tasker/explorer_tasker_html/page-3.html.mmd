<%= raw @titre %>
<%= raw link_other_pages(@page_index, @projet) %>


### Destruction effective de la tÃ¢che

Donc, dans le nouvelle mÃ©thode que jâ€™ai crÃ©Ã©e, il faut que :

1) je dÃ©truise la tÃ¢che choisie,
2) je retourne vers la liste des tÃ¢ches,
3) ou je reste lÃ  avec un affichage dâ€™erreur.

Mais avant de dÃ©truire la tÃ¢che, je voudrais apprendre Ã  la rÃ©cupÃ©rer dans la base de donnÃ©es afin de faire un message de confirmation un peu plus explicite oÃ¹ je nâ€™aurais pas que lâ€™identifiant.

Pour Ã§a, je mâ€™inspire une application exemple que jâ€™ai gÃ©nÃ©rÃ©e avec `mix phx.gen.html` (ou `live` je ne sais plus) et qui a crÃ©Ã© tout le code pour moi.

Ã‡a me permet de crÃ©er cette mÃ©thode dans path(lib/try1/taches.ex), le module qui contient toutes les mÃ©thodes de communication avec la base de donnÃ©es. Jâ€™y implÃ©mente :

~~~elixir
# in lib/try1/taches.ex

# sous la fonction 'liste_des_taches'
def get_tache!(id), do: Repo.get!(Tache, id)
~~~

Maintenant, dans mon `mount`, je vais pouvoir normalement rÃ©cupÃ©rer la tÃ¢che et lâ€™envoyer au render.

> Je crois avoir bien compris, maintenant, que tout ce que jâ€™assignais au `socket` ici Ã©tait accessible dans son `assigns` donc par `@<nom variable>` comme on peut le lire dans la documentation de Phoenix.

Jâ€™essaie donc :

~~~elixir
def mount(%{"id" => tache_id}, _session, socket) do
  tache = Try1.Taches.get_tache!(tache_id)
  {:ok, assign(socket, :tache, tache)}
end
~~~

> Note 1
>
> Jâ€™ai donc remplacÃ© lâ€™utilisation de `tache_id` par `tache`.
>
> Note 2
>
> Au lieu de `Task1.Taches` je pourrais aussi utiliser `*alias Try1.Taches` et mettre seulement `Taches`. Mais bonâ€¦ comme ce module ne va pas comporter beaucoup de code, lâ€™alias ne me semble pas se justifier.

Jâ€™ai un render maintenant qui utilise `@tache`Â :

~~~elixir
def render(assigns) do
  ~H"""
  <h2>Confirmation de la suppression</h2>
  <div>
    Merci de confirmer la suppression de la tÃ¢che 
    #<%= @tache.id %> 
    (<%= @tache.titre %>).
  </div>
  <div class="center">
    <.button 
      phx-click="remove_tache"
      data-tache_id={@tache.id}
      >
      DÃ©truire la tÃ¢che <%= @tache.id %>
    </.button>
  </div>

  """
end
~~~

> Noter tous les `@tache_id` qui ont Ã©tÃ© remplacÃ©s par des `@tache.id`

Je relance le serveur (jâ€™avais interrompu mon travail) avec un `mix phx.mix` en me rendant Ã  lâ€™adresse path(http://localhost:4000/taches/list), je clique sur la poubelle dâ€™une tÃ¢che etâ€¦ miracleÂ ! non seulement aucune erreur ne se produit mais le titre de la tÃ¢che sâ€™affiche bien entre parenthÃ¨sesÂ ! ğŸ¥³

Jâ€™implÃ©mente maintenant, vÃ©ritablement, la destruction de la tÃ¢che.

Dans le Â«Â repo-communicateurÂ Â» (il faudrait que je trouve un nom plus sympa), jâ€™implÃ©mente la mÃ©thode de destruction en mâ€™inspirant, pareil, des mÃ©thodes automatiques que jâ€™ai gÃ©nÃ©rÃ©es dans dâ€™autres applications rÃ©fÃ©rences.

~~~elixir
# in lib/try1/taches.ex

 @doc """
  DÃ©truit une tÃ¢che.

  ## Exemples

      iex> detruis_la_tache(tache)
      {:ok, %Tache{}}

      iex> detruis_la_tache(tache)
      {:error, %Ecto.Changeset{}}

  """
  def detruis_la_tache(%Tache{} = tache) do
    Repo.delete(tache)
  end

~~~

Note : Je garde les commentaires, car je sais quâ€™au-delÃ  de la documentation automatique que Ã§a permet, la section `## Exemples` permet aussi de faire des tests automatiques. Ici, le premier sera jouÃ©e, dÃ©truisant la tÃ¢che, et quand le deuxiÃ¨me essayera de la dÃ©truire Ã  nouveau, Ã§a ne sera pas possible. 

Note 2Â : je voudrais me servir de Ã§a pour voir comment on gÃ¨re une erreur de ce type dans ma fonction dâ€™Ã©vÃ¨nement.

Note 3 : Pour le moment, je ne suis pas encore tout Ã  fait Ã  lâ€™aise avec la tournure `%Tache{} = tache` qui est je crois propre Ã  Elixir, pas Ã  Phoenix. Je sais que `%Tache{}` dÃ©crit un modÃ¨le de type `Tache`, je sais que `tache` sera le nom de lâ€™instance envoyÃ©e dans la fonction, mais je ne comprends pas trop le `=` qui lit tout Ã§aâ€¦

Intuitivement, je modifie la fonction de cette maniÃ¨reÂ :

~~~elixir
# in lib/try1_web/live/taches/tache_rem.ex

def handle_event("remove_tache", params, socket) do
  case Try1.Taches.detruis_la_tache(@tache) do
  	{:ok, _tache} ->
    	{:noreply, 
    		socket |> put_flash(
    			:info, 
    			"TÃ¢che ##{@tache.id} dÃ©truite avec succÃ¨s."
    		)
    	}
    {:error, _tache} ->
    	{:noreply, 
    		socket |> put_flash(
    			:error, 
    			"# Impossible de dÃ©truire la tÃ¢che ##{@tache.id}.")}
    end
  end

~~~

Et jâ€™essaieâ€¦ ğŸ¤ğŸ¼

Evidemment, Ã§a ne passe pas. Jâ€™obtiens lâ€™erreurÂ : `(FunctionClauseError) no function clause matching in Try1.Taches.detruis_la_tache/1`.

Jâ€™ai lâ€™impression que le message suivant `lib/try1/taches.ex:36: Try1.Taches.detruis_la_tache(nil)` indique que `@tache` est nil.

Je teste `@tache` en entrÃ©e de la fonction remove_tache. Je sais quâ€™il y aurait des meilleurs moyens de pister une donnÃ©e, mais je ne sais pas encore le faire. Pour le moment, jâ€™ajoute juste : 

~~~elixir
def handle_event("remove_tache", params, socket) do
	IO.puts "@tache="
	IO.inspect @tache
	IO.puts "/@tache"
	...
~~~

Effectivement `@tache` est `nil` mais pourtant, je la vois dÃ©finie dans le message dâ€™erreur rougeâ€¦ Je vais essayer avec `socket.assigns.tache`, peut-Ãªtre que le raccourci `@` ne fonctionne pas iciâ€¦

~~~elixir
def handle_event("remove_tache", params, socket) do
	IO.puts "@tache="
	IO.inspect socket.assigns.tache
	IO.puts "/@tache"
	...
~~~

BingoÂ ! Cette fois, jâ€™obtiens la tÃ¢che. Je vais donc modifier mon code pour prendre la tÃ¢che lÃ . Ã‡a donnera, au dÃ©but de la fonctionÂ :

~~~elixir
def handle_event("remove_tache", params, socket) do
	tache = socket.assigns.tache
  case Try1.Taches.detruis_la_tache(tache) do
~~~

Jâ€™ai toujours dâ€™un erreur, mais un peu plus complexe cette fois, systÃ©mique, Ã  lâ€™Ã©cranÂ :

~~~
Phoenix.LiveView.ReloadError at GET /taches/1/delete
Try1Web.TacheRem raised Ecto.NoResultsError during connected mount sending a 404 response
~~~

Intuitivement, je comprends lâ€™erreur comme Ã§a : ici, je demande Ã  dÃ©truire la tÃ¢che, puis je reviens sur la mÃªme page, oÃ¹ lâ€™on doit confirmer la destruction de cette mÃªme page. Sauf que lorsque le `mount` essaie de trouver la tÃ¢che, il ne la trouve plus.

Pour vÃ©rifier, je peux dÃ©jÃ  voir si la tÃ¢che a bien Ã©tÃ© dÃ©truite.

Jâ€™ouvre une nouvelle fenÃªtre de terminal au dossier de mon application et je tapeÂ :

~~~bash
> psql -U philippeperret
psql# \connect try1_dev
try1_dev# SELECT * FROM taches;
~~~

â€¦ et effectivement, je vois que ma premiÃ¨re tÃ¢che a bien Ã©tÃ© dÃ©truite ! ğŸ¥³

Donc, aprÃ¨s la destruction, je dois rediriger vers la liste des tÃ¢ches. Je modifie la ligne de rÃ©ussite dans ma mÃ©thode `handle_event("remove_tache"...)`

~~~elixir
# En cas de rÃ©ussite :
{ :noreply, 
	socket 
		|> put_flash(:info, "TÃ¢che ##{@tache.id} dÃ©truite.")
    |> redirect(to: ~p"/taches/list")
 }
~~~

Il faut bien sÃ»r que je revienne Ã  la liste (path(http://localhost:4000/taches/list)) pour choisir une autre tÃ¢che Ã  dÃ©truire.

Jâ€™essaie une nouvelle foisâ€¦ ğŸ¤ğŸ¼	

Ã‡a gÃ©nÃ¨re la mÃªme erreurâ€¦ `Try1Web.TacheRem raised Ecto.NoResultsError during connected mount sending a 404 response`.

Apparemment, Ã§a repasse quand mÃªme par `mount` mÃªme aprÃ¨s avoir dÃ©truit la tÃ¢che. Je vais vÃ©rifier pour en Ãªtre sÃ»r en mettant des points dâ€™entrÃ©e dans les fonctions (`IO.puts â€˜-> mountâ€™` etc.) et en ne dÃ©truisant pas la tÃ¢che.

NON, en fait, Ã§a venait simplement du fait que jâ€™utilisais `@tache` dans les messages de rÃ©sultat au lieu de `tache`. 

Maintenant que câ€™est corrigÃ©, tout est parfait, la tÃ¢che est dÃ©truite et on revient Ã  la liste des tÃ¢chesÂ ! ğŸ’ªğŸ¼

### Petit reformatage des minutes

Avant de passer Ã  la suite, je voudrais corriger le fait que les minutes sâ€™affichent sur un chiffre quand elles sont infÃ©rieures Ã  10. Je modifie mon helper en ajoutant :

~~~elixir
def formate_date(date) do
	...
	# On ajoute le temps
  mn = date.minute
  mn_str = (mn < 10 && "0" || "") <> to_string(mn)
  d <> " - #{date.hour}:#{mn_str}"
end

~~~

Yes! ğŸ‘

### Try3

AprÃ¨s la destruction de la tÃ¢che, je vais passer Ã  Â«Â try3Â Â» pour commencer Ã  travailler un gros morceau indispensable : les associations.

> Chaque fois que je fais un nouveau dossier, je dÃ©truis le sous-dossier `_build` et `deps` de lâ€™ancien, qui sont particuliÃ¨rement lourds, puisquâ€™ils pourront Ãªtre reconstruits avec les commandes respectives `mix deps.get` et `mix compile` (ou simplement `mix phx.server`)

Lâ€™idÃ©e, ici, est donc maintenant de travailler avec des jointures de table (donc des clÃ©s Ã©trangÃ¨res, des *associations* comme ils semblent les appeler dans Phoenix â€” ailleurs aussi ?)

Dans un premier temps, on va crÃ©er la mise en Ã©dition dâ€™une tÃ¢che. Je frÃ©mis dâ€™avance.ğŸ˜…

On crÃ©e comme dâ€™hab la route,  live aussi, en sâ€™inspirant beaucoup de la destruction de la tÃ¢che.

~~~elixir
# in router.ex

scope "/taches/:id", Try1Web do
	...
	live "/edit", TacheEdit
end
~~~

Je crÃ©e le module path(lib/try1_web/live/taches/tache_edit.ex) en dupliquant simplement le module path(tache_rem.ex) et en faisant les modifications nÃ©cessaires. Jâ€™obtiens :

~~~elixir
# in lib/try1_web/live/taches/tache_edit.ex

defmodule Try1Web.TacheEdit do
  use Try1Web, :live_view
  import Try1Web.CoreComponents

  alias Try1.Taches

  def render(assigns) do
    ~H"""
    <h2>Modification de la tÃ¢che</h2>
    <div>Ici le formulaire</div>
    """
  end
  
  def mount(%{"id" => tache_id}, _session, socket) do
    tache = Try1.Taches.get_tache!(tache_id)
    {:ok, assign(socket, :tache, tache)}
  end

end
~~~

Cette fois, je nâ€™ai pas envie de travailler avec la fonction `render` et jâ€™ai lu quelque part que pour ne pas le faire, il suffisait de crÃ©er une vue (`.html.heex`) au mÃªme niveau avec le mÃªme nom de fichier.

Je crÃ©e donc le fichier path(lib/try1_web/live/taches/tache_edit.html.heex), je copie-colle dedans le code et je dÃ©truis la fonction `render`.

Pour essayer tout de suite lâ€™efficacitÃ©, voilÃ  le code que je mets dans la vue, avec dÃ©jÃ  un appel Ã  la tÃ¢che qui a dÃ» Ãªtre assignÃ©e au socket.

~~~html
<h2>Modification de la tÃ¢che</h2>
<div>Tache <%= @tache.titre %></div>
<div>Ici le formulaire</div>
~~~

Je lance le serveur et je me rends Ã  [path(http://localhost:4000/taches/list)](http://localhost:4000/taches/list). Et je clique sur le bouton dâ€™Ã©dition de la premiÃ¨re tÃ¢che.

Jâ€™adore quand Ã§a fonctionne du premier coupÂ ! âœŠ (jâ€™avais juste un doute sur la route du bouton dâ€™Ã©dition et je nâ€™ai pas voulu vÃ©rifier â€” ce quâ€™on peut Ãªtre fou parfois ! ğŸ˜‚).

Maintenant, je vais crÃ©er le formulaire. Mais avant Ã§a, je vais modifier un peu le layout pour avoir le texte plus Ã  gauche. Je fais Ã§a en modifiant le fichier path(layouts/app.html.heex) et notamment la classe des deux Ã©lÃ©ments.

### Le formulaire dâ€™Ã©dition de la tÃ¢che

Je vais aller chercher le formulaire utilisÃ© pour la crÃ©ation de la tÃ¢che puisque Ã§a sera le mÃªme. Jâ€™imagine que plus tard je pourrai prendre le mÃªme fichier-vue, mais pour le moment, je ne sais pas le faire (hormis, peut-Ãªtre, en utilisant un `render/3` dans une fonction `render/1` de mon module Live ?

Ce formulaire se trouve dans la fonction `render/1` du module path(live/taches/tache.ex).

Pour le moment, si je le copie-colle, Ã§a va gÃ©nÃ©rer une erreur normal, puisque la variable `@form` nâ€™est pas dÃ©finie. Il faut que je fasse comme Ã  la crÃ©ation mais cette fois en prenant les donnÃ©es de la tÃ¢che, relevÃ©es dans la BdD.

Dans un premier temps, je vais juste mâ€™inspirer du `mount/3` de `tache.ex` pour modifier celui de `tache_edit.ex`. AprÃ¨s quelques tÃ¢tonnements (et notamment quelques erreurs Ã  corriger), jâ€™obtiens :

~~~elixir
# in lib/try1_web/live/taches/tache_edit.ex
defmodule Try1Web.TacheEdit do
  use Try1Web, :live_view
  import Try1Web.CoreComponents

  alias Try1.Taches
  alias Try1.Tache

  def mount(%{"id" => tache_id}, _session, socket) do
    tache = Taches.get_tache!(tache_id)
    {:ok, assign(socket, %{
        form: to_form(Tache.changeset(%Tache{}, %{})),
        tache: tache
      }
    )}
  end

end
~~~

Pour essayer, je vais juste remplacer le deuxiÃ¨me paramÃ¨tres de `Tache.changeset`, qui est Ã  `%{}`, par la tÃ¢cheâ€¦ ğŸ¤ğŸ¼

Câ€™est en fait le premier ! Et Ã§a fonctionne ! Les donnÃ©es se placent dans le formulaireÂ !!! ğŸ’ªğŸ¼ğŸ¥³ğŸ‘

> Noter que je garde quand mÃªme lâ€™assignation de `tache` pour pouvoir utiliser `@tache` dans la vue, car on ne peut pas tout avoir par `@form`, Ã  commencer par `@form[:id]` pour obtenir lâ€™identifiant (jâ€™aime bien exposer les identifiants).

Mais lÃ , pour la suite, je vais Ãªtre obligÃ© de rÃ©flÃ©chir. Si je voulais me prÃ©cipiter, je copie-collerais les mÃ©thodes dâ€™Ã©vÃ¨nement Â«Â saveÂ Â» et Â«Â validateÂ Â» de lâ€™autre module pour que Ã§a fonctionne tout de suite iciâ€¦ Mais est-ce vraiment la meilleure maniÃ¨re de faire, entendu que Ã§a ne serait pas DRY du tout (DRY = Donâ€™t Repeat Yourself = Ne te rÃ©pÃ¨te pas, ne rÃ©pÃ¨te pas de code). Il doit bien y avoir une mÃ©thode pour rÃ©cupÃ©rer les autres.

Intuitivement, je me dirais quâ€™il suffirait dâ€™importer `tache.ex` dans `tache_edit.ex` pour *hÃ©riter* des fonctions (tout en Ã©crasant celle qui doivent Ãªtre propres, mais je ne trouve pas Ã§a super Ã©lÃ©gant. Je vais aller voir comment câ€™est gÃ©rÃ© dans dâ€™autres applications.

> En explorant du code, je suis tombÃ© sur cette tournure que je compte bien utiliser : 
>
> ~~~html
> <.back 
> 	navigate={~p"/products"}
> >Back to products</.back>
> ~~~

Dans un des codes explorÃ©s, les deux vues (Â«Â editÂ Â» et Â«Â newÂ Â») font simplement appel au mÃªme helper en envoyant leur `changeset` et leur `action`. 

Lâ€™exemple fonctionne avec beaucoup de convention. Je le dÃ©taille :

Lâ€™objet Ã©ditÃ©/crÃ©Ã© est un `product` (un produit). Dans un dossier path(lib/app_web/controllers/product_html/) on trouve :

* `new.html.heex` qui est la vue qui va permettre de crÃ©er le produit au dÃ©part,
* `edit.html.heex`, la vue qui va permettre dâ€™Ã©diter le produit ensuite
* `product_form.html.heex` qui contient le formulaire. Je crois que ce nom est dÃ©fini par convention et doit impÃ©rativement sâ€™appeler comme Ã§a. Il est construit Ã  partir de : path(<model>_form.html.heex)

DÃ©tail du contenu de chaque fichier, pour bien comprendre (NB. Je ne prends que les lignes qui sont intÃ©ressantes pour notre comprÃ©hension) :

**`new.html.heex`**

~~~html
<.product_form 
	changeset={@changeset}
	action={~p"/products"} 
/>
~~~

**`edit.html.heex`**

~~~html
<.header>
  Edit Product <%= @product.id %>
</.header>

<.product_form 
	changeset={@changeset}
	action={~p"/products/#{@product}"} 
/>
~~~

**`product_form.html.heex`**

~~~html
<.simple_form :let={f} for={@changeset} action={@action}>
  <.error :if={@changeset.action}>
    Oops, des erreurs ! Cf. ci-dessous.
  </.error>
  <.input field={f[:title]} type="text" label="Title" />
  <.input field={f[:description]} type="text" label="Description" />
  <.input field={f[:price]} type="number" label="Price" step="any" />
  <.input field={f[:views]} type="number" label="Views" />
  <:actions>
    <.button>Save Product</.button>
  </:actions>
</.simple_form>

~~~

La seule diffÃ©rence *fonctionnelle* notable, câ€™est la diffÃ©rence de `action` :

* `/products/<id produit>` pour lâ€™Ã©dition,
* `/products` (donc la liste, je pense) pour la crÃ©ation.

Donc la crÃ©ation conduit Ã  la liste des produits tandis que lâ€™Ã©dition conduit Ã  lâ€™affichage du produit.

Le helper path(.product_form) est dÃ©fini dans Â :
path(lib/app_web/controllers/product_html.ex). Ici aussi, le nom est dÃ©fini par convention pour pouvoir fonctionner, je pense (jâ€™en suis mÃªme presque certain. Dans ce module, le helper est simplement implÃ©mentÃ© pour charger (par dÃ©faut) sa vue (le path(product_form.html.heex) ci-dessus)Â :

~~~elixir
defmodule HelloWeb.ProductHTML do
  use HelloWeb, :html

  embed_templates "product_html/*"

  @doc """
  Renders a product form.
  """
  attr :changeset, Ecto.Changeset, required: true
  attr :action, :string, required: true

  def product_form(assigns)
end
~~~

On notera, comme je lâ€™ai lu dans la documentation, la dÃ©claration des variables au-dessus de la fonction avec les `attr`. On retrouve, en toute logique, `changeset` et `action`.

On note la ligne 4 qui indique le dossier oÃ¹ prendre les vues.

<%= raw link_other_pages(@page_index, @projet) %>