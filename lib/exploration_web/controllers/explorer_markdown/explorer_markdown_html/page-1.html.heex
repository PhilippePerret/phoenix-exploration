<%= raw @titre %>
<%= raw link_other_pages(@page_index, @projet) %>
<div class="p">Dans cette application, je vais donc aller jusquâ€™Ã  la crÃ©ation dâ€™une extension (ou package, ou dÃ©pendance, câ€™est selon) pour traiter les fichiers markdown, quelque chose de plus Ã©tendu que le package [phoenix-markdown][3] qui va me servir nÃ©anmoins dâ€™exemple.</div>
<h3>Par extension de fichier</h3>
<div class="p">Je veux que ce soit, comme phoenix-markdown, un <em>moteur de rendu</em>, câ€™est-Ã -dire quâ€™il suffise dâ€™utiliser une certaine extension de fichier pour que le fichier soit traitÃ© avec ce moteur de rendu. En lâ€™occurrence, il sâ€™agira de lâ€™extension <code>.mmd</code>.</div>
<div class="p">> Est-ce que Ã§a ne fait pas confusion avec <nowrap>Â«&nbsp;multi-markdown&nbsp;Â»&nbsp;?</nowrap>â€¦ Est-ce quâ€™il ne vaudrait pas mieux <code>.ppmd</code> mÃªme si câ€™est un peu <nowrap>long&nbsp;?</nowrap></div>
<div class="p">Jâ€™ai remarquÃ© comment le dÃ©finir trÃ¨s simplement dans <nowrap><code>config/config.ex</code>&nbsp;:</nowrap></div>
<pre><code lang="elixir">
config :mon_app, :template_engines, mmd: MonMoteur.Engine
</code></pre>
<h3>DÃ©pendances</h3>
<div class="p">Comme je vais partir de phoenix-markdown, jâ€™ajoute cette dÃ©pendance ainsi que <em>:earmak</em> (utile aussi, mais je ne sais pas encore pourquoi) Ã  <nowrap><code>mix.ex</code>&nbsp;:</nowrap></div>
<pre><code lang="elixir">
{:phoenix_markdown, "~> 1.0"},
{:earmark, "~> 1.4"},
</code></pre>
<div class="p">Je vais utiliser <a href="https://github.com/elixir-makeup/makeup/" target="_blank">markup</a> et <a href="https://github.com/elixir-makeup/makeup_elixir" target="_blank">markup-elixir</a> pour la colorisation syntaxique, il faut donc que jâ€™ajouter ces dÃ©pendances Ã  <nowrap><code>mix.ex</code>&nbsp;:</nowrap></div>
<pre><code lang="elixir">
{:makeup, "1.2.1"},
{:makeup_elixir, "~> 0.14.0"}
</code></pre>
<div class="p">Jâ€™ai aussi besoin dâ€™un fichier CSS qui dÃ©finira les couleurs. Jâ€™ai choisi <code>perldoc</code> que jâ€™aime bien, avec peu de contraste. Jâ€™ai du le modifier un peu pour quâ€™il contienne tout. Jâ€™ai placÃ© le fichier dans <code>assets/css/highlight/perldoc.css</code> et je lâ€™ai chargÃ© avec le code suivant dans mon <nowrap><code>assets/css/app.css</code>&nbsp;:</nowrap></div>
<pre><code lang="css">
@import "highlight/perldoc.css";
</code></pre>
<div class="p">Ce fichier, Ã  lâ€™heure oÃ¹ vous lisez ces lignes, est trÃ¨s <nowrap>exactement&nbsp;:</nowrap></div>
<pre><code lang="css">
&lt;span class="text-sm italic">(source : assets/css/highlight/perldoc.css)&lt;/span>

.makeup .hll { background-color: #ffffcc }
pre.makeup code  { 
/* background: #eeeedd;  */
background-color: #ffffcc;
color:black;
}
.makeup .c { color: #228B22 } /* Comment */
.makeup .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.makeup .err { color: #a61717; background-color: transparent } /* Error */
.makeup .k { color: #8B008B; font-weight: bold } /* Keyword */
.makeup .ch { color: #228B22 } /* Comment.Hashbang */
.makeup .cm { color: #228B22 } /* Comment.Multiline */
.makeup .cp { color: #1e889b } /* Comment.Preproc */
.makeup .cpf { color: #228B22 } /* Comment.PreprocFile */
.makeup .c1 { color: #228B22 } /* Comment.Single */
.makeup .cs { color: #8B008B; font-weight: bold } /* Comment.Special */
.makeup .gd { color: #aa0000 } /* Generic.Deleted */
.makeup .ge { font-style: italic } /* Generic.Emph */
.makeup .gr { color: #aa0000 } /* Generic.Error */
.makeup .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.makeup .gi { color: #00aa00 } /* Generic.Inserted */
.makeup .go { color: #888888 } /* Generic.Output */
.makeup .gp { color: #555555 } /* Generic.Prompt */
.makeup .gs { font-weight: bold } /* Generic.Strong */
.makeup .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.makeup .gt { color: #aa0000 } /* Generic.Traceback */
.makeup .kc { color: #8B008B; font-weight: bold } /* Keyword.Constant */
.makeup .kd { color: #8B008B; font-weight: bold } /* Keyword.Declaration */
.makeup .kn { color: #8B008B; font-weight: bold } /* Keyword.Namespace */
.makeup .kp { color: #8B008B; font-weight: bold } /* Keyword.Pseudo */
.makeup .kr { color: #8B008B; font-weight: bold } /* Keyword.Reserved */
.makeup .kt { color: #00688B; font-weight: bold } /* Keyword.Type */
.makeup .m { color: #B452CD } /* Literal.Number */
.makeup .s { color: #CD5555 } /* Literal.String */
.makeup .n { color: #658bCC; font-weight: bold; } /* Name.Attribute */
.makeup .na { color: #658b00 } /* Name.Attribute */
.makeup .nb { color: #658b00 } /* Name.Builtin */
.makeup .nc { color: #008b45; font-weight: bold } /* Name.Class */
.makeup .no { color: #00688B } /* Name.Constant */
.makeup .nd { color: #707a7c } /* Name.Decorator */
.makeup .ne { color: #008b45; font-weight: bold } /* Name.Exception */
.makeup .nf { color: #008b45 } /* Name.Function */
.makeup .nn { color: #008b45; text-decoration: underline } /* Name.Namespace */
.makeup .nt { color: #8B008B; font-weight: bold } /* Name.Tag */
.makeup .nv { color: #00688B } /* Name.Variable */
.makeup .ow { color: #8B008B } /* Operator.Word */
.makeup .w { color: #bbbbbb } /* Text.Whitespace */
.makeup .mb { color: #B452CD } /* Literal.Number.Bin */
.makeup .mf { color: #B452CD } /* Literal.Number.Float */
.makeup .mh { color: #B452CD } /* Literal.Number.Hex */
.makeup .mi { color: #B452CD } /* Literal.Number.Integer */
.makeup .mo { color: #B452CD } /* Literal.Number.Oct */
.makeup .sa { color: #CD5555 } /* Literal.String.Affix */
.makeup .sb { color: #CD5555 } /* Literal.String.Backtick */
.makeup .sc { color: #CD5555 } /* Literal.String.Char */
.makeup .dl { color: #CD5555 } /* Literal.String.Delimiter */
.makeup .sd { color: #CD5555 } /* Literal.String.Doc */
.makeup .s2 { color: #CD5555 } /* Literal.String.Double */
.makeup .se { color: #CD5555 } /* Literal.String.Escape */
.makeup .sh { color: #1c7e71; font-style: italic } /* Literal.String.Heredoc */
.makeup .si { color: #CD5555 } /* Literal.String.Interpol */
.makeup .sx { color: #cb6c20 } /* Literal.String.Other */
.makeup .sr { color: #1c7e71 } /* Literal.String.Regex */
.makeup .s1 { color: #CD5555 } /* Literal.String.Single */
.makeup .ss { color: #CD5555 } /* Literal.String.Symbol */
.makeup .bp { color: #658b00 } /* Name.Builtin.Pseudo */
.makeup .fm { color: #008b45 } /* Name.Function.Magic */
.makeup .vc { color: #00688B } /* Name.Variable.Class */
.makeup .vg { color: #00688B } /* Name.Variable.Global */
.makeup .vi { color: #00688B } /* Name.Variable.Instance */
.makeup .vm { color: #00688B } /* Name.Variable.Magic */
.makeup .il { color: #B452CD } /* Literal.Number.Integer.Long */

.makeup.document,
.makeup.markdown {
font-family: 'Times New Roman', Times, serif;
padding:0.5em 1.5em; 
font-size: 15pt;
}
</code></pre>
<div class="p">VoilÃ  pour les dÃ©pendances pour le moment.</div>
<h3>Installation</h3>
<div class="p">Comme je ne veux pas faire de dÃ©pendance pour le moment (je veux <nowrap>dire&nbsp;:</nowrap> un dossier Ã  charger avec les <em>deps</em>), je crÃ©e juste un dossier dÃ©diÃ© dans mon dossier <code>lib/exploration_web/components/</code> qui aura pour nom <code>pharkdown_1.0</code> (<nowrap>Â«&nbsp;pp&nbsp;Â»</nowrap> Ã©tant mes initiales) et dans lequel je mettrai tous mes fichiers.</div>
<div class="p">> Jâ€™ajoute la version Ã  la fin du nom du dossier parce que je me sers de ce moteur dans au moins deux applications en ce moment (LdQ et Exploration) et je risque de la bouger dans lâ€™une ou dans lâ€™autre. Donc il faut toujours que je sache quelle est la derniÃ¨re version jâ€™utilise. Pour le savoir, dÃ¨s que je fais une modification, jâ€™incrÃ©mente la version (je passe par exemple de <nowrap>Â«&nbsp;3.2&nbsp;Â»</nowrap> Ã  <nowrap>Â«&nbsp;3.3&nbsp;Â»</nowrap>). Lorsque je passe Ã  lâ€™autre application, je peux vÃ©rifier que jâ€™ai bien la derniÃ¨re version.</div>
<div class="p">Mon module sâ€™appellera <strong>PPMarkdown</strong>.</div>
<div class="p">Je commence par mettre dans ce dossier un fichier <code>highlighter.ex</code> que jâ€™ai rÃ©cupÃ©rÃ© dans [nimble-publisher][1] (un autre projet de [JosÃ© Valim][2], le crÃ©ateur du langage Elixir).</div>
<h2>Les moteurs de rendu</h2>
<div class="p">Puisque je veux que Ã§a fonctionne en mettant en <nowrap>configuration&nbsp;:</nowrap> </div>
<pre><code lang="elixir">
config :mon_app, :template_engines, mmd: PPMarkdown.Engine
</code></pre>
<div class="p">â€¦ pour que dÃ¨s que lâ€™on a un fichier <code>mon_fichier.html.mmd</code> (donc oÃ¹ lâ€™extension est <code>.mmd</code> le fichier soit traitÃ© par mon moteur de rendu <code>PPMarkdown.Engine</code>).</div>
<h3>CrÃ©ation d'un engin simple</h3>
<div class="p">AprÃ¨s consultation de la documentation sur les moteurs de rendus, je crÃ©e le fichier <code>lib/exploration_web/controllers/my_markdown_engin.ex</code> dans lequel je <nowrap>place&nbsp;:</nowrap></div>
<pre><code lang="elixir">
defmodule PPMarkdown.Engine do
@behaviour Phoenix.Template.Engine

TOKEN8NEKOT
TOKEN9NEKOT
TOKEN10NEKOT

def compile\(path, name) do

TOKEN11NEKOT
TOKEN12NEKOT
options = %{}

path
|> File.read!()         # je lis le code du fichier
|> mmd_transformations\(options)  # je le traite
|> EEx.compile_string\(
engine: Phoenix.HTML.Engine, 
file: path, 
line: 1
)
end

TOKEN13NEKOT
defp mmd_transformations\(code, options) do
"&lt;p>Je vais transformer le code Â« #{code} Â»&lt;/p>"
end

end
</code></pre>
<div class="p">Et je lâ€™essaie sur ma page <a href="<%= ~p"/explorer/markdown/?ipage=2" %>">explorer_markdown_html/page-test.html.mmd</a> (revenir en cliquant sur le bouton <nowrap>Â«&nbsp;Retour</nowrap> en <nowrap>arriÃ¨re&nbsp;Â»</nowrap> du navigateur ou choisir dâ€™ouvrir la page dans une nouvelle fenÃªtre).</div>
<div class="p"><nowrap>Bingo&nbsp;!</nowrap> ðŸ¥³ Ã‡a <nowrap>fonctionne&nbsp;!</nowrap> Je suis bien passÃ© par le moteur de rendu et je peux maintenant traiter le code Ã  ma guise.</div>
<h2>Traitements de base</h2>
<h3>HTML embarquÃ©</h3>
<div class="p">Dâ€™abord, il faut que je rÃ¨gle le problÃ¨me des balises HTML qui sâ€™Ã©crire <nowrap>Â«&nbsp;en</nowrap> <nowrap>dur&nbsp;Â»</nowrap> si elles se trouvent dans le texte. Par exemple, si le code dans la page <nowrap>est&nbsp;:</nowrap></div>
<pre><code lang="markdown">
Ceci est une &lt;span id="balise">balise&lt;/span>.
</code></pre>
<div class="p">â€¦ alors le code restera tel quel Ã  lâ€™affichage, alors que devrait <nowrap>sâ€™afficher&nbsp;:</nowrap></div>
<pre><code lang="document">
Ceci est une balise.
</code></pre>
<div class="p">Jâ€™obtiens ce rÃ©sultat (en tout cas partiellement) en <nowrap>ajoutant&nbsp;:</nowrap></div>
<pre><code lang="elixir">
|> EEx.compile_string\(engine: Phoenix.HTML.Engine, file: path, line: 1)
</code></pre>
<div class="p">â€¦ comme dans le package markdown. Mon code <nowrap>devient&nbsp;:</nowrap></div>
<pre><code lang="elixir">
def compile\(path, name) do

TOKEN16NEKOT
options = %{}

path
|> File.read!()  
|> mmd_transformations\(options)
|> EEx.compile_string\(
engine: Phoenix.HTML.Engine, 
file: path, 
line: 1
)
end
</code></pre>
<div class="p">Pour garder les traitements markdown de base, jâ€™ajoute la ligne de <nowrap>traitement&nbsp;:</nowrap></div>
<pre><code lang="elixir">
path
|> File.read!()  
|> Earmark.as_html!(earmark_options\()) # &lt;=== +
|> mmd_transformations\(options)
|> EEx.compile_string\(engine: Phoenix.HTML.Engine, file: path, line: 1)
</code></pre>
<div class="p">Et comme je veux utiliser tous les traitements de PhoenixMarkdown, mais que je ne veux pas faire un appel au module Ã  lâ€™intÃ©rieur de mon moteur de vue, je copie-colle tout son code dans le mien. Je ferais juste une citation en dÃ©but de fichier.</div>
<%= raw link_other_pages(@page_index, @projet) %>
<div class="p">[1]: https://github.com/dashbitco/nimble_publisher/tree/master</div>
<div class="p">[2]: https://pl.linkedin.com/in/josevalim</div>
<div class="p">[3]: https://github.com/boydm/phoenix_markdown</div>