<%= raw @titre %>
<%= raw link_other_pages(@page_index, @projet) %>

Dans cette application, je vais donc aller jusquâ€™Ã  la crÃ©ation dâ€™une extension (ou package, ou dÃ©pendance, câ€™est selon) pour traiter les fichiers markdown, quelque chose de plus Ã©tendu que le package [phoenix-markdown][3] qui va me servir nÃ©anmoins dâ€™exemple.

### Par extension de fichier

Je veux que ce soit, comme phoenix-markdown, un *moteur de rendu*, câ€™est-Ã -dire quâ€™il suffise dâ€™utiliser une certaine extension de fichier pour que le fichier soit traitÃ© avec ce moteur de rendu. En lâ€™occurrence, il sâ€™agira de lâ€™extension path(.mmd).

> Est-ce que Ã§a ne fait pas confusion avec Â«Â multi-markdownÂ Â» ?â€¦ Est-ce quâ€™il ne vaudrait pas mieux path(.ppmd) mÃªme si câ€™est un peu long ?

Jâ€™ai remarquÃ© comment le dÃ©finir trÃ¨s simplement dans path(config/config.ex)Â :

~~~elixir
config :mon_app, :template_engines, mmd: MonMoteur.Engine
~~~

### DÃ©pendances

Comme je vais partir de phoenix-markdown, jâ€™ajoute cette dÃ©pendance ainsi que *:earmak* (utile aussi, mais je ne sais pas encore pourquoi) Ã  path(mix.ex)Â :

~~~elixir
{:phoenix_markdown, "~> 1.0"},
{:earmark, "~> 1.4"},
~~~

Je vais utiliser [markup](https://github.com/elixir-makeup/makeup/) et [markup-elixir](https://github.com/elixir-makeup/makeup_elixir) pour la colorisation syntaxique, il faut donc que jâ€™ajouter ces dÃ©pendances Ã  path(mix.ex)Â :

~~~elixir
{:makeup, "1.2.1"},
{:makeup_elixir, "~> 0.14.0"}
~~~

Jâ€™ai aussi besoin dâ€™un fichier CSS qui dÃ©finira les couleurs. Jâ€™ai choisi path(perldoc) que jâ€™aime bien, avec peu de contraste. Jâ€™ai du le modifier un peu pour quâ€™il contienne tout. Jâ€™ai placÃ© le fichier dans path(assets/css/highlight/perldoc.css) et je l'ai chargÃ© avec le code suivant dans mon path(assets/css/app.css)Â :

~~~css
@import "highlight/perldoc.css";
~~~

Ce fichier, Ã  lâ€™heure oÃ¹ vous lisez ces lignes, est trÃ¨s exactementÂ :

load_as_code(assets/css/highlight/perldoc.css)

VoilÃ  pour les dÃ©pendances pour le moment.

### Installation

Comme je ne veux pas faire de dÃ©pendance pour le moment (je veux dire : un dossier Ã  charger avec les *deps*), je crÃ©e juste un dossier dÃ©diÃ© dans mon dossier path(lib/exploration_web/components/) qui aura pour nom path(pp_markdown_1.0) (Â«Â ppÂ Â» Ã©tant mes initiales) et dans lequel je mettrai tous mes fichiers.

> J'ajoute la version Ã  la fin du nom du dossier parce que je me sers de ce moteur dans au moins deux applications en ce moment (LdQ et Exploration) et je risque de la bouger dans l'une ou dans l'autre. Donc il faut toujours que je sache quelle est la derniÃ¨re version j'utilise. Pour le savoir, dÃ¨s que je fais une modification, j'incrÃ©mente la version (je passe par exemple de "3.2" Ã  "3.3"). Lorsque je passe Ã  l'autre application, je peux vÃ©rifier que j'ai bien la derniÃ¨re version.

Mon module sâ€™appellera **PPMarkdown**.

Je commence par mettre dans ce dossier un fichier path(highlighter.ex) que jâ€™ai rÃ©cupÃ©rÃ© dans [nimble-publisher][1] (un autre projet de [JosÃ© Valim][2], le crÃ©ateur du langage Elixir).

## Les moteurs de rendu

Puisque je veux que Ã§a fonctionne en mettant en configuration : 

~~~elixir
config :mon_app, :template_engines, mmd: PPMarkdown.Engine
~~~

â€¦ pour que dÃ¨s que lâ€™on a un fichier path(mon_fichier.html.mmd) (donc oÃ¹ lâ€™extension est path(.mmd) le fichier soit traitÃ© par mon moteur de rendu `PPMarkdown.Engine`).

### CrÃ©ation d'un engin simple

AprÃ¨s consultation de la documentation sur les moteurs de rendus, je crÃ©e le fichier path(lib/exploration_web/controllers/my_markdown_engin.ex) dans lequel je place :

~~~elixir
defmodule PPMarkdown.Engine do
  @behaviour Phoenix.Template.Engine

  # Cette mÃ©thode est la seule obligatoire et
  # c'est celle qui sera appelÃ©e par le rendu (par
  # la demande de rendu de la page)
  
  def compile(path, name) do

    # Plus tard, on pourra dÃ©finir des options Ã 
    # partir des configurations
    options = %{}

    path
    |> File.read!()         # je lis le code du fichier
    |> mmd_transformations(options)  # je le traite
    |> EEx.compile_string(
        engine: Phoenix.HTML.Engine, 
        file: path, 
        line: 1
        )
  end

  # MÃ©thode principale de traitement du code
  defp mmd_transformations(code, options) do
    "<p>Je vais transformer le code Â« #{code} Â»</p>"
  end

end 
~~~

Et je l'essaie sur ma page [explorer_markdown_html/page-test.html.mmd](<%= ~p"/explorer/markdown/?ipage=2" %>) (revenir en cliquant sur le bouton Â« Retour en arriÃ¨re Â» du navigateur ou choisir dâ€™ouvrir la page dans une nouvelle fenÃªtre).

Bingo ! ðŸ¥³ Ã‡a fonctionne ! Je suis bien passÃ© par le moteur de rendu et je peux maintenant traiter le code Ã  ma guise.

## Traitements de base

### HTML embarquÃ©

D'abord, il faut que je rÃ¨gle le problÃ¨me des balises HTML qui sâ€™Ã©crire Â«Â en durÂ Â» si elles se trouvent dans le texte. Par exemple, si le code dans la page est :

~~~markdown
Ceci est une <span id="balise">balise</span>.
~~~

â€¦ alors le code restera tel quel Ã  lâ€™affichage, alors que devrait sâ€™afficherÂ :

~~~document
Ceci est une balise.
~~~

J'obtiens ce rÃ©sultat (en tout cas partiellement) en ajoutantÂ :

~~~elixir
|> EEx.compile_string(engine: Phoenix.HTML.Engine, file: path, line: 1)
~~~

â€¦ comme dans le package markdown. Mon code devient :

~~~elixir
def compile(path, name) do

  # Plus tard, on pourra dÃ©finir des options
  options = %{}

  path
  |> File.read!()  
  |> mmd_transformations(options)
  |> EEx.compile_string(
      engine: Phoenix.HTML.Engine, 
      file: path, 
      line: 1
      )
end
~~~

Pour garder les traitements markdown de base, j'ajoute la ligne de traitement :

~~~elixir
path
|> File.read!()  
|> Earmark.as_html!(earmark_options()) # <=== +
|> mmd_transformations(options)
|> EEx.compile_string(engine: Phoenix.HTML.Engine, file: path, line: 1)
~~~

Et comme je veux utiliser tous les traitements de PhoenixMarkdown, mais que je ne veux pas faire un appel au module Ã  l'intÃ©rieur de mon moteur de vue, je copie-colle tout son code dans le mien. Je ferais juste une citation en dÃ©but de fichier.

<%= raw link_other_pages(@page_index, @projet) %>


[1]: https://github.com/dashbitco/nimble_publisher/tree/master
[2]: https://pl.linkedin.com/in/josevalim
[3]: https://github.com/boydm/phoenix_markdown
