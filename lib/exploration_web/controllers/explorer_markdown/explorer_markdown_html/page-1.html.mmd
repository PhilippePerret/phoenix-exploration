# Exploration deâ€¦ MARKDOWN<br />CrÃ©ation dâ€™un package pour Phoenix/elixir

Dans cette application, je vais donc aller jusquâ€™Ã  la crÃ©ation dâ€™une extension (ou package, ou dÃ©pendance, câ€™est selon) pour traiter les fichiers markdown, quelque chose de plus Ã©tendu que le package [phoenix-markdown]() qui va me servir nÃ©anmoins dâ€™exemple.

### Par extension de fichier

Je veux que ce soit, comme phoenix-markdown, un *moteur de rendu*, câ€™est-Ã -dire quâ€™il suffise dâ€™utiliser une certaine extension de fichier pour que le fichier soit traitÃ© avec ce moteur de rendu. En lâ€™occurrence, il sâ€™agira de lâ€™extension path(.mmd).

> Est-ce que Ã§a ne fait pas confusion avec Â«Â multi-markdownÂ Â» ?â€¦ Est-ce quâ€™il ne vaudrait pas mieux path(.ppmd) mÃªme si câ€™est un peu long ?

Jâ€™ai remarquÃ© comment le dÃ©finir trÃ¨s simplement dans path(config/config.ex)Â :

~~~elixir
config :mon_app, :template_engines, mmd: MonMoteur.Engine
~~~

### DÃ©pendances

Comme je vais partir de phoenix-markdown, jâ€™ajoute cette dÃ©pendance ainsi que *:earmak* (utile aussi, mais je ne sais pas encore pourquoi) Ã  path(mix.ex)Â :

~~~elixir
{:phoenix_markdown, "~> 1.0"},
{:earmark, "~> 1.4"},
~~~

Je vais utiliser [markup](https://github.com/elixir-makeup/makeup/) et [markup-elixir](https://github.com/elixir-makeup/makeup_elixir) pour la colorisation syntaxique, il faut donc que jâ€™ajouter ces dÃ©pendances Ã  path(mix.ex)Â :

~~~elixir
{:makeup, "1.2.1"},
{:makeup_elixir, "~> 0.14.0"}
~~~

Jâ€™ai aussi besoin dâ€™un fichier CSS qui dÃ©finira les couleurs. Jâ€™ai choisi path(perldoc) que jâ€™aime bien, avec peu de contraste. Jâ€™ai du le modifier un peu pour quâ€™il contienne tout. Jâ€™ai placÃ© le fichier dans path(assets/css/highlight/perldoc.css) et je l'ai chargÃ© avec le code suivant dans mon path(assets/css/app.css)Â :

~~~css
@import "highlight/perldoc.css";
~~~

Ce fichier, Ã  lâ€™heure oÃ¹ vous lisez ces lignes, est trÃ¨s exactementÂ :

load_as_code(assets/css/highlight/perldoc.css)


VoilÃ  pour les dÃ©pendances pour le moment.

### Installation

Comme je ne veux pas faire de dÃ©pendance pour le moment, je crÃ©e juste un dossier dÃ©diÃ© dans mon dossier path(lib/exploration_web/components/) qui aura pour nom path(pp_markdown_1.0) (Â«Â ppÂ Â» Ã©tant mes initiales) et dans lequel je mettrai tous mes fichiers.

> J'ajoute la version Ã  la fin du nom du dossier parce que je me sers de ce moteur dans au moins deux applications en ce moment (LdQ et Exploration) et je risque de la bouger dans l'une ou dans l'autre. Donc il faut toujours que je sache quelle est la derniÃ¨re version j'utilise. Pour le savoir, dÃ¨s que je fais une modification, j'incrÃ©mente la version (je passe par exemple de "3.2" Ã  "3.3"). Lorsque je passe Ã  l'autre application, je peux vÃ©rifier que j'ai bien la derniÃ¨re version.

Mon module sâ€™appellera **PPMarkdown**.

Je commence par mettre dans ce dossier un fichier path(highlighter.ex) que jâ€™ai rÃ©cupÃ©rÃ© dans [nimble-publisher][1] (un autre projet de [JosÃ© Valim][2], le crÃ©ateur du langage Elixir).


### Les moteurs de rendu

Dans un premier temps, je voudrais m'intÃ©resser aux *moteurs de rendu* (*Template Engines*) qui permettre de traiter les vues.

## Essai de crÃ©ation d'un engin simple

AprÃ¨s consultation de la documentation sur les moteurs de rendus, je crÃ©e le fichier path(lib/exploration_web/controllers/my_markdown_engin.ex) dans lequel je place :

~~~elixir
defmodule PPMarkdown.Engine do
  @behaviour Phoenix.Template.Engine

  # Cette mÃ©thode est la seule obligatoire
  def compile(path, name) do

    # Plus tard, on pourra dÃ©finir des options
    options = %{}

    path
    |> File.read!()         # je lis le code du fichier
    |> mmd_transformations(options)  # je le traite
    |> EEx.compile_string(
        engine: Phoenix.HTML.Engine, 
        file: path, 
        line: 1
        )
  end

  # MÃ©thode principale de traitement du code
  defp my_as_html(code, options) do
    "<p>Je vais transformer le code Â« #{code} Â»</p>"
  end

end 
~~~

Maintenant, je vais dire Ã  mon application que les fichiers `.mmd` doivent utiliser ce moteur de rendu.

J'ajoute donc Ã  path(config/config.ex) :

~~~elixir
# in config/config.ex

...

config :phoenix, :template_engines, mmd: MyMarkdown.Engine

...
~~~

Et je l'essaie sur ma page [explorer_markdown_html/page-2.html.mmd](<%= ~p"/explorer/markdown/?ipage=2" %>) (revenir en cliquant sur le bouton Â« Retour en arriÃ¨re Â» du navigateur).

Bingo ! ðŸ¥³ Ã‡a fonctionne ! Je suis bien passÃ© par le moteur de rendu et je peux maintenant traiter le code Ã  ma guise.

D'abord, il faut que je rÃ¨gle le problÃ¨me des balises HTML qui se mettent en dur.

J'obtiens le rÃ©sultat voulu en ajoutantÂ :

~~~elixir
|> EEx.compile_string(engine: Phoenix.HTML.Engine, file: path, line: 1)
~~~

â€¦ comme dans le package markdown. Mon code devient :

~~~elixir
def compile(path, name) do

  # Plus tard, on pourra dÃ©finir des options
  options = %{}

  path
  |> File.read!()  
  |> mmd_transformations(options)
  |> EEx.compile_string(
      engine: Phoenix.HTML.Engine, 
      file: path, 
      line: 1
      )
end
~~~

### Traitement Markdown de base

Pour garder les traitements markdown de base, j'ajoute la ligne de traitement :

~~~elixir
path
|> File.read!()  
|> Earmark.as_html!(earmark_options()) # <=== +
|> mmd_transformations(options)
|> EEx.compile_string(engine: Phoenix.HTML.Engine, file: path, line: 1)
~~~

Et comme je veux utiliser tous les traitements de PhoenixMarkdown, mais que je ne sais pas encore faire un appel au module Ã  l'intÃ©rieur de mon moteur de vue, je copie-colle tout le texte.

### Premiers traitements

En premire lieu, pour cette application d'exploration particuliÃ¨re, comme j'ai beaucoup de chemins d'accÃ¨s Ã  Ã©crire, je voudrais pouvoir appliquer facilement leur style en utilisant :

~~~elixir
<%= "path" <> "(chemin/acces/au_fichier)" %>
~~~

Je crÃ©e donc la mÃ©thode :

~~~elixir
defp transforme_paths(code) do
  Regex.replace(~r"path\((.*)\)"U, code, "<path>\\1</path>")
end
~~~

Ma mÃ©thode `mmd_transformations` devient donc :

~~~elixir
defp mmd_transformations(code, _options) do
  code 
  |> transforme_paths()
end
~~~




Je veux pouvoir traiter les codes `<.fonction ...>`.

<.link_next_page index=2 />


[1]: https://github.com/dashbitco/nimble_publisher/tree/master
[2]: https://pl.linkedin.com/in/josevalim
