load(_entete)

## ComprÃ©hension des modules

Avant de poursuivre, je voudrais mieux fixer ma comprÃ©hension des modules pour savoir si je les comprends bien. Je veux dire, rÃ©pondre Ã  ma question toute simpleÂ : est-ce que lorsque je crÃ©e un fichier module nâ€™importe oÃ¹, est-ce quâ€™il est accessible Ã  toutes les autres parties et tous les autres modules.

Pour Ã§a, je crÃ©e une nouvelle petite application expÃ©rimentale que jâ€™appelle `modul`.

~~~bash
mix phx.new modul
~~~

Je modifie dÃ©jÃ  la page dâ€™accueil pour quâ€™il nâ€™y ait presque plus rien.

Sur cette page dâ€™accueil, je vais utiliser la variable `@valeur` pour pouvoir obtenir et afficher la valeur retournÃ©e par les modules.

~~~html
<!-- in controllers/page_html/home.html.heex -->

...

<p>@valeur vaut : '<%= @valeur %>'</p>

~~~

Ã‰videmment, dÃ¨s que je fais Ã§a, lâ€™application rÃ¢le, il faut que je dÃ©finisse cette variable.

~~~elixir
# in controller/page_controller.ex

...

def home(conn, _params) do
	render(conn, :home, valeur: get_valeur())
end

def get_valeur() do
	"nulle"
end
~~~



### Module en dehors de tout

Je commence par crÃ©er un module en dehors du dossier lib, donc Ã  la racine de lâ€™application, que jâ€™appelle `moduleout.ex`Â :

~~~elixir
# in <app>/moduleout.ex

defmodule ModuleOut do

	def run do
		"Je suis la fonction ModuleOut.run"
	end
		
end
~~~

Et jâ€™appelle ce module et cette fonction depuis mon contrÃ´leurÂ :

~~~elixir
# in controller/page_controller.ex

def get_valeur() do
	ModuleOut.run()
end
~~~

Lâ€™application rÃ¢le, elle ne connait pas le module `ModuleOut`.

Jâ€™ajoute un import pour voirÂ :

~~~elixir
# in controller/page_controller.ex
defmodule ModulWeb.PageController do
	use ModuleWeb, :controller
	
	import ModuleOut # +

~~~

Lâ€™application est incapable de trouver le module.

### Module dans le dossier `lib`

Je crÃ©e maintenant un module dans le dossier `lib`, de nom `module_in.ex`.

~~~elixir
# in lib/module_in.ex

defmodule ModuleIn do
	def run do
		"je suis la fonction run du module ModuleIn"
	end
end
~~~

Jâ€™appelle cette fonction pour obtenir la valeur.

~~~elixir
# in controller/page_controller.ex

def get_valeur() do
	ModuleIn.run()
end
~~~

Cette fois, mÃªme sans lâ€™importer, je peux obtenir la valeur. La page affiche bienÂ :

~~~document
@valeur vaut : 'je suis la fonction run du module ModuleIn'
~~~

### Non correspondance du nom

Une question que je me pose aussi Ã  chaque fois, câ€™est de savoir si le nom du fichier doit correspondre au nom du module (`ModuleIn` => `module_in.ex` et lâ€™inverse : `module_in.ex` => module de nom `ModuleIn`). Le savoir, je change donc le nom du fichier pour path(mon_module.ex).

â€¦

Ã‡a ne pose aucun problÃ¨me. En tout cas pour un module comme Ã§a, qui nâ€™est en rapport avec rien dâ€™autre.

### AccessibilitÃ© depuis la vue

Je voudrais voir aussi si ce module peut Ãªtre utilisÃ© directement depuis une vue. Donc, dans mon fichier path(page_html/home.html.heex) jâ€™ajoute : 

~~~html
<p>Par un appel direct j'obtiens : <%= ModuleIn.run() %></p>
~~~

Et Ã§a fonctionne parfaitementÂ ! 

Jâ€™essaie tout de suite avec un module qui serait dans path(/lib/modul)Â :

~~~elixir
# in ./lib/modul/module_in_modul.ex

defmodule ModInModul do

	def run() do
		"je suis la fonction run dans ModInModul."
	end
end
~~~

â€¦ et je place donc dans la vue :

~~~html
<p>Par un appel direct Ã  ModInModul, j'obtiens : <%= ModInModul.run() %></p>
~~~

â€¦

Et Ã§a fonctionne parfaitement aussiÂ !

### Essai des composants HEX

Je voudrais tout de suite voir si on peut utiliser des composants Hex qui seraient dÃ©finis dans ces modules.

Jâ€™ajoute donc Ã  ma vue, le code suivant qui, Ã©videmment, va rÃ¢ler tout de suiteÂ :

~~~html
<!-- dans home.html.heex -->
...
<p>Bonjour, <.prenom name="Phil" exclamatif={true}/></p>
<p>Bonjour, <.prenom name="Phil" exclamatif={false}/></p>
~~~

Et dans path(module_in.ex) jâ€™implÃ©mente :

~~~elixir
# in module_in.ex

def prenom(assigns) do
	~H"<%= @name %>"
end
~~~

Ã‡a ne fonctionne pas, jâ€™essaie de mieux dÃ©finir le composant, comme il se doit :

~~~elixir
# in module_in.ex

use Phoenix.Component

attr :name, :string
def prenom(assigns) do
	~H"<%= @name %>"
end
~~~

Ã‡a ne change rien.

Je vais essayer dâ€™importer (ou dâ€™utiliser avec `use`) le module `ModuleIn` dans `PageController`Â :

~~~elixir
# in controller/page_controller.ex
defmodule ModulWeb.PageController do
	use ModuleWeb, :controller
	
	import ModuleIn 		# +
	
	# ou
	
	use ModuleIn 				# +

~~~

Ni lâ€™un ni lâ€™autre ne fonctionne.

### Faire fonctionner les composants

Ma premiÃ¨re supposition est que le module qui dÃ©finit les composants doit Ãªtre prÃ©fixÃ© `ModulWeb` (le nom du module de lâ€™application auquel on ajoute `Web`) et se trouver dans le dossier path(lib/app_web).

Jâ€™ai donc trois choses Ã  essayer :

- un module Ã  lâ€™extÃ©rieur de path(modul_web) mais qui Â«Â augmenteÂ Â» le module `ModulWeb`,
- un module dans path(modul_web) qui nâ€™augmente pas le module `ModulWeb`
- un module qui fait les deux : dans p(modul_web) et qui augment le module `ModulWeb`.

Je commence par le troisiÃ¨me car, a priori, si celui-ci ne fonctionne pas, aucun des autres ne fonctionnera. Donc :

~~~elixir
# in lib/modul_web/components/module_in_components.ex

defmodule ModelWeb.MesComponents do 
	use Phoenix.Component

	attr :name, :string
	def prenom(assigns) do
		~H"mon cher <%= @nom %>"
	end
	
end
~~~

> Ã€ titre de rappel, un composant doit toujours ne comporter quâ€™un seul paramÃ¨tres, `assigns`, qui contient les attributs dÃ©finis dans la balise `<.composant attr=valeur attr=valeur ... />`
>
> Quand on dÃ©finit `attr :name, :string` on dÃ©finit un attribut quâ€™on doit trouver en attribut, dans le type dÃ©fini, mais Ã§a permet aussi de dÃ©finir des valeurs par dÃ©faut, par exemple `attr :name, :string, default: "Truc"`
>
> Il faut aussi, obligatoirement (me semble-t-il), que la fonction utilise le sigil `H`.

â€¦

Et Ã§a fonctionne impeccablement, mais seulement si jâ€™importe ce module. Pour le moment, je lâ€™ai importÃ© dans p(lib/modul_web/page_html.ex) oÃ¹ Ã§a me semblait le plus logique. 

~~~elixir
# in lib/modul_web/page_html.ex

import ModelWeb.MesComponents

~~~

### Lieu de dÃ©finition du composant

Je vais essayer maintenant de lâ€™importer dans un seulement de ces modules :

- dans le contrÃ´leur (p(lib/modul_web/page_controller.ex)),
- dans le module layout principal 
  (p(lib/modul_web/components/layout.ex)),
- dans le module des composants fournis 
  (p(lib/modul_web/components/core_components.ex))

Ã‡a ne fonctionne dans aucun de ces trois modules, donc il faut vraiment **les importer dans le module HTML du contrÃ´leur si on veut utiliser des composants HEX**.

Je vais maintenant essayer de dÃ©finir les composants ailleurs, comme je lâ€™ai voulu.

Je mets dans ma page p(home.html.heex) ce code : 

~~~html
<!-- in home.html.heex -->

...
<p>PremiÃ¨re provenance <.ou1 /></p>
<p>DeuxiÃ¨me provenance <.ou2 /></p>
~~~

Ã‰videmment, Ã§a rÃ¢leâ€¦

Mais dÃ¨s que jâ€™ai crÃ©Ã© les modules dans les deux places dÃ©finies (p(&lt;app>/) et p(app_web/)), mÃªme sans que ces modules nâ€™augmentent `AppWeb`, il suffit de les importer pour que Ã§a fonctionne. Le dÃ©tail :

~~~elixir
# in lib/modul/components_in_module.ex

defmodule MesComponentsInModule do
  use Phoenix.Component
  def ou1(assigns) do
    ~H"Moi je viens de ou1 dans lib/modul/components_in_modul.ex."
  end
end
~~~

~~~elixir
# in lib/modul_web/controllers/autres_components.ex

defmodule MesAutresComponentsInControllers do 
  use Phoenix.Component
  def ou2(assigns) do
    ~H"Je viens de ou2 dans controllers/autres_components.ex."
  end
end
~~~

Et je les importe dans le module HTML :

~~~elixir
# in lib/modul_web/controllers/page_html.ex

defmodule ModulWeb.PageHTML do
	...
	import ModelWeb.MesComponents
  import MesComponentsInModule							# +
  import MesAutresComponentsInControllers		# +
	...
end
~~~

### Des modules dans des modules

Jâ€™ai une derniÃ¨re chose Ã  essayer concernant les composants, câ€™est voir si je peux rassemble lâ€™importation dans un seul module et, de cette maniÃ¨re, nâ€™avoir quâ€™un seul module Ã  important dans les modules HTML.

Je vais donc essayer dâ€™importer mes deux derniers modules dans le premier. Et donc supprimer les lignes dâ€™import ci-dessus pour ne garder que `import ModelWeb.MesComponents`.

â€¦

Ã‡a ne fonctionne pas. Ã‡a fonctionne seulement si jâ€™importe avec `alias` et que je redÃ©finis les fonctions â€” en renvoyant tout de suite aux originalesÂ â€”, mais câ€™est vraiment lourd. Donc, par exempleÂ : 

~~~elixir
# in lib/modul_web/components/modul_in_components.ex

alias MesComponentsInModule, as: M1
alias MesAutresComponentsInControllers, as: M2

def ou1(assigns), do: M1.ou1(assigns)
def ou2(assigns), do: M2.ou2(assigns)

~~~

Il y a peut-Ãªtre des cas oÃ¹ Ã§a peut Ãªtre pratique, mais bonâ€¦ il vaut mieux pour le moment importer tous les modules de composants (en partant du principe quâ€™ils seront bien organisÃ©s et nommÃ©s) dans les modules HTML qui en auront besoin.

## Conclusion

Je crois que dans un premier temps jâ€™ai terminÃ© lâ€™exploration de ces modules et que Ã§a mâ€™a bien renseignÃ© sur les possibilitÃ©s offertes.

- Les modules Â«Â normauxÂ Â» peuvent Ãªtre dÃ©finis nâ€™importe oÃ¹ et utilisÃ©s sans avoir Ã  les importer.
- Les fonctions dÃ©finis dans ces modules peuvent Ãªtre utilisÃ©es dans les vues, sans Ãªtre importÃ©s non plus.
- Les composants peuvent Ãªtre dÃ©finis oÃ¹ lâ€™on veut, et avec le nom que lâ€™on veut. On pourrait par exemple les rassembler dans un dossier p(app/lib/app_web/components/custom_components/).
- Les modules de composants doivent Ãªtre importÃ©s dans les modules HTML des pages qui doivent les utiliser.

On peut passer Ã  la suite de lâ€™explorationÂ ! ðŸš€



load(_pied_de_page)